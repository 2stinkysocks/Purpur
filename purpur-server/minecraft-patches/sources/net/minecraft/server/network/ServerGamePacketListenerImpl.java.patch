--- a/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -326,6 +_,20 @@
         this.chatMessageChain = new FutureChain(server.chatExecutor); // CraftBukkit - async chat
     }
 
+    // Purpur start - AFK API
+    private final com.google.common.cache.LoadingCache<org.bukkit.craftbukkit.entity.CraftPlayer, Boolean> kickPermissionCache = com.google.common.cache.CacheBuilder.newBuilder()
+        .maximumSize(1000)
+        .expireAfterWrite(1, java.util.concurrent.TimeUnit.MINUTES)
+        .build(
+            new com.google.common.cache.CacheLoader<>() {
+                @Override
+                public Boolean load(org.bukkit.craftbukkit.entity.CraftPlayer player) {
+                    return player.hasPermission("purpur.bypassIdleKick");
+                }
+            }
+        );
+    // Purpur end - AFK API
+
     @Override
     public void tick() {
         if (this.ackBlockChangesUpTo > -1) {
@@ -384,6 +_,12 @@
         if (this.player.getLastActionTime() > 0L
             && this.server.getPlayerIdleTimeout() > 0
             && Util.getMillis() - this.player.getLastActionTime() > this.server.getPlayerIdleTimeout() * 1000L * 60L && !this.player.wonGame) { // Paper - Prevent AFK kick while watching end credits
+            // Purpur start - AFK API
+            this.player.setAfk(true);
+            if (!this.player.level().purpurConfig.idleTimeoutKick || (!Boolean.parseBoolean(System.getenv("PURPUR_FORCE_IDLE_KICK")) && kickPermissionCache.getUnchecked(this.player.getBukkitEntity()))) {
+                return;
+            }
+            // Purpur end - AFK API
             this.player.resetLastActionTime(); // CraftBukkit - SPIGOT-854
             this.disconnect(Component.translatable("multiplayer.disconnect.idling"), org.bukkit.event.player.PlayerKickEvent.Cause.IDLING); // Paper - kick event cause
         }
@@ -629,6 +_,8 @@
                     this.lastYaw = to.getYaw();
                     this.lastPitch = to.getPitch();
 
+                    if (!to.getWorld().getUID().equals(from.getWorld().getUID()) || to.getBlockX() != from.getBlockX() || to.getBlockY() != from.getBlockY() || to.getBlockZ() != from.getBlockZ() || to.getYaw() != from.getYaw() || to.getPitch() != from.getPitch()) this.player.resetLastActionTime(); // Purpur - AFK API
+
                     Location oldTo = to.clone();
                     PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
                     this.cserver.getPluginManager().callEvent(event);
@@ -1169,6 +_,10 @@
             final int maxBookPageSize = pageMax.intValue();
             final double multiplier = Math.clamp(io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.bookSize.totalMultiplier, 0.3D, 1D);
             long byteAllowed = maxBookPageSize;
+            // Purpur start - PlayerBookTooLargeEvent
+            int slot = packet.slot();
+            ItemStack itemstack = Inventory.isHotbarSlot(slot) || slot == Inventory.SLOT_OFFHAND ? this.player.getInventory().getItem(slot) : ItemStack.EMPTY;
+            // Purpur end - PlayerBookTooLargeEvent
             for (final String page : pageList) {
                 final int byteLength = page.getBytes(java.nio.charset.StandardCharsets.UTF_8).length;
                 byteTotal += byteLength;
@@ -1193,7 +_,8 @@
             }
 
             if (byteTotal > byteAllowed) {
-                ServerGamePacketListenerImpl.LOGGER.warn("{} tried to send a book too large. Book size: {} - Allowed: {} - Pages: {}", this.player.getScoreboardName(), byteTotal, byteAllowed, pageList.size());
+                ServerGamePacketListenerImpl.LOGGER.warn("{} tried to send too large of a book. Book size: {} - Allowed: {} - Pages: {}", this.player.getScoreboardName(), byteTotal, byteAllowed, pageList.size());
+                org.purpurmc.purpur.event.player.PlayerBookTooLargeEvent event = new org.purpurmc.purpur.event.player.PlayerBookTooLargeEvent(player.getBukkitEntity(), itemstack.asBukkitCopy()); if (event.shouldKickPlayer()) // Purpur - PlayerBookTooLargeEvent
                 this.disconnectAsync(Component.literal("Book too large!"), org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // Paper - kick event cause // Paper - add proper async disconnect
                 return;
             }
@@ -1212,31 +_,45 @@
             Optional<String> optional = packet.title();
             optional.ifPresent(list::add);
             list.addAll(packet.pages());
+            // Purpur start - Allow color codes in books
+            boolean hasEditPerm = getCraftPlayer().hasPermission("purpur.book.color.edit");
+            boolean hasSignPerm = hasEditPerm || getCraftPlayer().hasPermission("purpur.book.color.sign");
+            // Purpur end - Allow color codes in books
             Consumer<List<FilteredText>> consumer = optional.isPresent()
-                ? texts -> this.signBook(texts.get(0), texts.subList(1, texts.size()), slot)
-                : texts -> this.updateBookContents(texts, slot);
+                ? texts -> this.signBook(texts.get(0), texts.subList(1, texts.size()), slot, hasSignPerm) // Purpur - Allow color codes in books
+                : texts -> this.updateBookContents(texts, slot, hasEditPerm); // Purpur - Allow color codes in books
             this.filterTextPacket(list).thenAcceptAsync(consumer, this.server);
         }
     }
 
     private void updateBookContents(List<FilteredText> pages, int index) {
+    // Purpur start - Allow color codes in books
+        updateBookContents(pages, index, false);
+    }
+    private void updateBookContents(List<FilteredText> pages, int index, boolean hasPerm) {
+    // Purpur end - Allow color codes in books
         // CraftBukkit start
         ItemStack handItem = this.player.getInventory().getItem(index);
         ItemStack item = handItem.copy();
         // CraftBukkit end
         if (item.has(DataComponents.WRITABLE_BOOK_CONTENT)) {
-            List<Filterable<String>> list = pages.stream().map(this::filterableFromOutgoing).toList();
+            List<Filterable<String>> list = pages.stream().map(filteredText -> filterableFromOutgoing(filteredText).map(s -> color(s, hasPerm))).toList(); // Purpur - Allow color codes in books
             item.set(DataComponents.WRITABLE_BOOK_CONTENT, new WritableBookContent(list));
             this.player.getInventory().setItem(index, CraftEventFactory.handleEditBookEvent(this.player, index, handItem, item)); // CraftBukkit // Paper - Don't ignore result (see other callsite for handleEditBookEvent)
         }
     }
 
     private void signBook(FilteredText title, List<FilteredText> pages, int index) {
+        // Purpur start - Allow color codes in books
+        signBook(title, pages, index, false);
+    }
+    private void signBook(FilteredText title, List<FilteredText> pages, int index, boolean hasPerm) {
+        // Purpur end - Allow color codes in books
         ItemStack item = this.player.getInventory().getItem(index);
         if (item.has(DataComponents.WRITABLE_BOOK_CONTENT)) {
             ItemStack itemStack = item.transmuteCopy(Items.WRITTEN_BOOK);
             itemStack.remove(DataComponents.WRITABLE_BOOK_CONTENT);
-            List<Filterable<Component>> list = pages.stream().map(filteredText -> this.filterableFromOutgoing(filteredText).<Component>map(Component::literal)).toList();
+            List<Filterable<Component>> list = pages.stream().map((filteredText) -> this.filterableFromOutgoing(filteredText).map(s -> hexColor(s, hasPerm))).toList(); // Purpur - Allow color codes in books
             itemStack.set(
                 DataComponents.WRITTEN_BOOK_CONTENT,
                 new WrittenBookContent(this.filterableFromOutgoing(title), this.player.getName().getString(), 0, list, true)
@@ -1250,6 +_,16 @@
         return this.player.isTextFilteringEnabled() ? Filterable.passThrough(filteredText.filteredOrEmpty()) : Filterable.from(filteredText);
     }
 
+    // Purpur start - Allow color codes in books
+    private Component hexColor(String str, boolean hasPerm) {
+        return hasPerm ? PaperAdventure.asVanilla(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacyAmpersand().deserialize(str)) : Component.literal(str);
+    }
+
+    private String color(String str, boolean hasPerm) {
+        return hasPerm ? org.bukkit.ChatColor.color(str, false) : str;
+    }
+    // Purpur end - Allow color codes in books
+
     @Override
     public void handleEntityTagQuery(ServerboundEntityTagQueryPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel());
@@ -1460,7 +_,7 @@
                                     movedWrongly = true;
                                     if (event.getLogWarning())
                                     // Paper end
-                                LOGGER.warn("{} moved wrongly!", this.player.getName().getString());
+                                LOGGER.warn("{} moved wrongly!, ({})", this.player.getName().getString(), verticalDelta); // Purpur - AFK API
                                 } // Paper
                             }
 
@@ -1526,6 +_,8 @@
                                     this.lastYaw = to.getYaw();
                                     this.lastPitch = to.getPitch();
 
+                                    if (!to.getWorld().getUID().equals(from.getWorld().getUID()) || to.getBlockX() != from.getBlockX() || to.getBlockY() != from.getBlockY() || to.getBlockZ() != from.getBlockZ() || to.getYaw() != from.getYaw() || to.getPitch() != from.getPitch()) this.player.resetLastActionTime(); // Purpur - AFK API
+
                                     Location oldTo = to.clone();
                                     PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
                                     this.cserver.getPluginManager().callEvent(event);
@@ -1582,6 +_,13 @@
                                     this.player.tryResetCurrentImpulseContext();
                                 }
 
+                                // Purpur start - Dont run with scissors!
+                                if (this.player.serverLevel().purpurConfig.dontRunWithScissors && this.player.isSprinting() && !(this.player.serverLevel().purpurConfig.ignoreScissorsInWater && this.player.isInWater()) && !(this.player.serverLevel().purpurConfig.ignoreScissorsInLava && this.player.isInLava()) && (isScissors(this.player.getItemInHand(InteractionHand.MAIN_HAND)) || isScissors(this.player.getItemInHand(InteractionHand.OFF_HAND))) && (int) (Math.random() * 10) == 0) {
+                                    this.player.hurtServer(this.player.serverLevel(), this.player.damageSources().scissors(), (float) this.player.serverLevel().purpurConfig.scissorsRunningDamage);
+                                    if (!org.purpurmc.purpur.PurpurConfig.dontRunWithScissors.isBlank()) this.player.sendActionBarMessage(org.purpurmc.purpur.PurpurConfig.dontRunWithScissors);
+                                }
+                                // Purpur end - Dont run with scissors!
+
                                 this.player.checkMovementStatistics(this.player.getX() - x, this.player.getY() - y, this.player.getZ() - z);
                                 this.lastGoodX = this.player.getX();
                                 this.lastGoodY = this.player.getY();
@@ -1630,6 +_,17 @@
         }
     }
 
+    // Purpur start - Dont run with scissors!
+    public boolean isScissors(ItemStack stack) {
+        if (!stack.is(Items.SHEARS)) return false;
+
+        ResourceLocation itemModelReference = stack.get(net.minecraft.core.component.DataComponents.ITEM_MODEL);
+        if (itemModelReference != null && itemModelReference.equals(this.player.serverLevel().purpurConfig.dontRunWithScissorsItemModelReference)) return true;
+
+        return stack.getOrDefault(DataComponents.CUSTOM_MODEL_DATA, net.minecraft.world.item.component.CustomModelData.EMPTY).equals(net.minecraft.world.item.component.CustomModelData.EMPTY);
+    }
+    // Purpur end - Dont run with scissors!
+
     // Paper start - optimise out extra getCubes
     private boolean hasNewCollision(final ServerLevel level, final Entity entity, final AABB oldBox, final AABB newBox) {
         final List<AABB> collisionsBB = new java.util.ArrayList<>();
@@ -2734,6 +_,7 @@
 
                 AABB boundingBox = target.getBoundingBox();
                 if (this.player.canInteractWithEntity(boundingBox, io.papermc.paper.configuration.GlobalConfiguration.get().misc.clientInteractionLeniencyDistance.or(3.0))) { // Paper - configurable lenience value for interact range
+                    if (target instanceof net.minecraft.world.entity.Mob mob) mob.ticksSinceLastInteraction = 0; // Purpur - Entity lifespan
                     packet.dispatch(
                         new ServerboundInteractPacket.Handler() {
                             private void performInteraction(InteractionHand hand, ServerGamePacketListenerImpl.EntityInteraction entityInteraction, PlayerInteractEntityEvent event) { // CraftBukkit
