--- a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -41,6 +_,7 @@
     private long keepAliveChallenge;
     private long closedListenerTime;
     private boolean closed = false;
+    private it.unimi.dsi.fastutil.longs.LongList keepAlives = new it.unimi.dsi.fastutil.longs.LongArrayList(); // Purpur - Alternative Keepalive Handling
     private int latency;
     private volatile boolean suspendFlushingOnServerThread = false;
     // CraftBukkit start
@@ -51,6 +_,7 @@
     public final java.util.Map<java.util.UUID, net.kyori.adventure.resource.ResourcePackCallback> packCallbacks = new java.util.concurrent.ConcurrentHashMap<>(); // Paper - adventure resource pack callbacks
     private static final long KEEPALIVE_LIMIT = Long.getLong("paper.playerconnection.keepalive", 30) * 1000; // Paper - provide property to set keepalive limit
     protected static final net.minecraft.resources.ResourceLocation MINECRAFT_BRAND = net.minecraft.resources.ResourceLocation.withDefaultNamespace("brand"); // Paper - Brand support
+    protected static final net.minecraft.resources.ResourceLocation PURPUR_CLIENT = net.minecraft.resources.ResourceLocation.fromNamespaceAndPath("purpur", "client"); // Purpur - Purpur client support
 
     public ServerCommonPacketListenerImpl(MinecraftServer server, Connection connection, CommonListenerCookie cookie, net.minecraft.server.level.ServerPlayer player) { // CraftBukkit
         this.server = server;
@@ -118,6 +_,16 @@
 
     @Override
     public void handleKeepAlive(ServerboundKeepAlivePacket packet) {
+        // Purpur start - Alternative Keepalive Handling
+        if (org.purpurmc.purpur.PurpurConfig.useAlternateKeepAlive) {
+            if (this.keepAlivePending && !keepAlives.isEmpty() && keepAlives.contains(packet.getId())) {
+                int ping = (int) (Util.getMillis() - packet.getId());
+                this.latency = (this.latency * 3 + ping) / 4;
+                this.keepAlivePending = false;
+                keepAlives.clear(); // we got a valid response, lets roll with it and forget the rest
+            }
+        } else
+        // Purpur end - Alternative Keepalive Handling
         if (this.keepAlivePending && packet.getId() == this.keepAliveChallenge) {
             int i = (int)(Util.getMillis() - this.keepAliveTime);
             this.latency = (this.latency * 3 + i) / 4;
@@ -159,6 +_,13 @@
                 ServerGamePacketListenerImpl.LOGGER.error("Couldn't register custom payload", ex);
                 this.disconnect(Component.literal("Invalid payload REGISTER!"), org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PAYLOAD); // Paper - kick event cause
             }
+        // Purpur start - Purpur client support
+        } else if (identifier.equals(PURPUR_CLIENT)) {
+            try {
+                player.purpurClient = true;
+            } catch (Exception ignore) {
+            }
+        // Purpur end - Purpur client support
         } else if (identifier.equals(ServerCommonPacketListenerImpl.CUSTOM_UNREGISTER)) {
             try {
                 String channels = payload.toString(com.google.common.base.Charsets.UTF_8);
@@ -238,6 +_,22 @@
         // Paper start - give clients a longer time to respond to pings as per pre 1.12.2 timings
         // This should effectively place the keepalive handling back to "as it was" before 1.12.2
         final long elapsedTime = millis - this.keepAliveTime;
+
+        // Purpur start - Alternative Keepalive Handling
+        if (org.purpurmc.purpur.PurpurConfig.useAlternateKeepAlive) {
+            if (elapsedTime >= 1000L) { // 1 second
+                if (this.keepAlivePending && !this.processedDisconnect && keepAlives.size() * 1000L >= KEEPALIVE_LIMIT) {
+                    this.disconnect(ServerCommonPacketListenerImpl.TIMEOUT_DISCONNECTION_MESSAGE, org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT);
+                } else if (this.checkIfClosed(millis)) {
+                    this.keepAlivePending = true;
+                    this.keepAliveTime = millis; // hijack this field for 1 second intervals
+                    this.keepAlives.add(millis); // currentTime is ID
+                    this.send(new ClientboundKeepAlivePacket(millis));
+                }
+            }
+        } else
+        // Purpur end - Alternative Keepalive Handling
+
         if (!this.isSingleplayerOwner() && elapsedTime >= 15000L) { // use vanilla's 15000L between keep alive packets
             if (this.keepAlivePending) {
                 if (!this.processedDisconnect && elapsedTime >= KEEPALIVE_LIMIT) { // check keepalive limit, don't fire if already disconnected
